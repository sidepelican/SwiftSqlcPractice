// Code generated by sqlc using sqlc-gen-from-template; DO NOT EDIT.
// Template: query_template.swift.tmpl

import Foundation
import SQLKit

public enum Query {
{{- range .Queries }}

  public enum {{ .Name }} {
    public static let name: String = "{{ .Name }}"
    public static let cmd: String = "{{ .Cmd }}"
    public static let sql: String = {{ printf "%q" .Text }}

    // Input type
    public struct Input: Sendable {
    {{- range $i, $p := .Params }}
      public var p{{ $p.Number }}: {{- $t := $p.Column.Type.Name -}}{{ if or (eq $t "INTEGER") (eq $t "integer") }}Int{{ else if or (eq $t "REAL") (eq $t "real") }}Double{{ else if or (eq $t "TEXT") (eq $t "text") }}String{{ else if or (eq $t "BLOB") (eq $t "blob") }}Data{{ else }}String{{ end }}{{ if not $p.Column.NotNull }}?{{ end }}
    {{- end }}
      public init({{- range $i, $p := .Params }}{{ if $i }}, {{ end }}p{{ $p.Number }}: {{- $t := $p.Column.Type.Name -}}{{ if or (eq $t "INTEGER") (eq $t "integer") }}Int{{ else if or (eq $t "REAL") (eq $t "real") }}Double{{ else if or (eq $t "TEXT") (eq $t "text") }}String{{ else if or (eq $t "BLOB") (eq $t "blob") }}Data{{ else }}String{{ end }}{{ if not $p.Column.NotNull }}?{{ end }}{{- end }}) {
      {{- range $i, $p := .Params }}
        self.p{{ $p.Number }} = p{{ $p.Number }}
      {{- end }}
      }
    }

    // Row type
    public struct Row: Sendable {
    {{- range $i, $c := .Columns }}
      public var {{ $c.Name }}: {{- $t := $c.Type.Name -}}{{ if or (eq $t "INTEGER") (eq $t "integer") }}Int{{ else if or (eq $t "REAL") (eq $t "real") }}Double{{ else if or (eq $t "TEXT") (eq $t "text") }}String{{ else if or (eq $t "BLOB") (eq $t "blob") }}Data{{ else }}String{{ end }}{{ if not $c.NotNull }}?{{ end }}
    {{- end }}
    }

    // Convenience runner (matches SQLKit async API)
    {{- if eq .Cmd ":many" }}
    public static func execute(on db: SQLDatabase, input: Input) async throws -> [Row] {
      var query = SqlcQueryString(sql)
      {{- range $i, $p := .Params }}
      query.bind(input.p{{ $p.Number }})
      {{- end }}
      let rows = try await db.raw("\(query)").all()
      var result: [Row] = []
      result.reserveCapacity(rows.count)
      for r in rows {
        result.append(Row(
        {{- range $i, $c := .Columns }}
          {{- if $i }}, {{ end -}}
          {{ $c.Name }}: try r.decode(column: r.allColumns[{{ $i }}], as: {{- $t := $c.Type.Name -}}{{ if or (eq $t "INTEGER") (eq $t "integer") }}Int{{ else if or (eq $t "REAL") (eq $t "real") }}Double{{ else if or (eq $t "TEXT") (eq $t "text") }}String{{ else if or (eq $t "BLOB") (eq $t "blob") }}Data{{ else }}String{{ end }}{{ if not $c.NotNull }}?.self{{ else }}.self{{ end }})
        {{- end }}
        ))
      }
      return result
    }
    {{- else if eq .Cmd ":one" }}
    public static func execute(on db: SQLDatabase, input: Input) async throws -> Row? {
      var query = SqlcQueryString(sql)
      {{- range $i, $p := .Params }}
      query.bind(input.p{{ $p.Number }})
      {{- end }}
      if let r = try await db.raw("\(query)").first() {
        return Row(
        {{- range $i, $c := .Columns }}
          {{- if $i }}, {{ end -}}
          {{ $c.Name }}: try r.decode(column: r.allColumns[{{ $i }}], as: {{- $t := $c.Type.Name -}}{{ if or (eq $t "INTEGER") (eq $t "integer") }}Int{{ else if or (eq $t "REAL") (eq $t "real") }}Double{{ else if or (eq $t "TEXT") (eq $t "text") }}String{{ else if or (eq $t "BLOB") (eq $t "blob") }}Data{{ else }}String{{ end }}{{ if not $c.NotNull }}?.self{{ else }}.self{{ end }})
        {{- end }}
        )
      }
      return nil
    }
    {{- else }}
    public static func execute(on db: SQLDatabase, input: Input) async throws {
      var query = SqlcQueryString(sql)
      {{- range $i, $p := .Params }}
      query.bind(input.p{{ $p.Number }})
      {{- end }}
      try await db.raw("\(query)").run()
    }
    {{- end }}
  }
{{- end }}
}
