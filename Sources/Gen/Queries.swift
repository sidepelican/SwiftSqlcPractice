// Code generated by sqlc using sqlc-gen-from-template; DO NOT EDIT.
// Template: query_template.swift.tmpl

import Foundation
import SQLiteNIO

public enum Query {

  public enum GetTracksByAlbum {
    public static let name: String = "GetTracksByAlbum"
    public static let cmd: String = ":many"
    public static let sql: String =
      "SELECT t.TrackId, t.Name, t.Milliseconds\nFROM tracks AS t\nWHERE t.AlbumId = ?1\nORDER BY t.TrackId"

    // Input type
    public struct Input: Sendable {
      public var p1: Int
      public init(p1: Int) {
        self.p1 = p1
      }
    }

    // Row type
    public struct Row: Sendable {
      public var trackid: Int
      public var name: String
      public var milliseconds: Int
    }

    // Convenience runner (matches SQLKit async API)
    public static func execute(on db: SQLiteConnection, input: Input) async throws -> [Row] {
      var query = SqlcQueryBuilder(sql)
      query.bind(input.p1)
      let rows = try await db.execute(query)
      var result: [Row] = []
      result.reserveCapacity(rows.count)
      for r in rows {
        result.append(
          Row(
            trackid: try r.decode(column: r.allColumns[0], as: Int.self),
            name: try r.decode(column: r.allColumns[1], as: String.self),
            milliseconds: try r.decode(column: r.allColumns[2], as: Int.self)
          ))
      }
      return result
    }
  }

  public enum SearchTracksByName {
    public static let name: String = "SearchTracksByName"
    public static let cmd: String = ":many"
    public static let sql: String =
      "SELECT TrackId, Name\nFROM tracks\nWHERE Name LIKE '%' || ?1 || '%'\nORDER BY Name\nLIMIT ?2"

    // Input type
    public struct Input: Sendable {
      public var p1: String?
      public var p2: Int
      public init(p1: String?, p2: Int) {
        self.p1 = p1
        self.p2 = p2
      }
    }

    // Row type
    public struct Row: Sendable {
      public var trackid: Int
      public var name: String
    }

    // Convenience runner (matches SQLKit async API)
    public static func execute(on db: SQLiteConnection, input: Input) async throws -> [Row] {
      var query = SqlcQueryBuilder(sql)
      query.bind(input.p1)
      query.bind(input.p2)
      let rows = try await db.execute(query)
      var result: [Row] = []
      result.reserveCapacity(rows.count)
      for r in rows {
        result.append(
          Row(
            trackid: try r.decode(column: r.allColumns[0], as: Int.self),
            name: try r.decode(column: r.allColumns[1], as: String.self)
          ))
      }
      return result
    }
  }

  public enum GetAlbumsByArtist {
    public static let name: String = "GetAlbumsByArtist"
    public static let cmd: String = ":many"
    public static let sql: String =
      "SELECT a.AlbumId, a.Title\nFROM albums AS a\nWHERE a.ArtistId = ?1\nORDER BY a.AlbumId"

    // Input type
    public struct Input: Sendable {
      public var p1: Int
      public init(p1: Int) {
        self.p1 = p1
      }
    }

    // Row type
    public struct Row: Sendable {
      public var albumid: Int
      public var title: String
    }

    // Convenience runner (matches SQLKit async API)
    public static func execute(on db: SQLiteConnection, input: Input) async throws -> [Row] {
      var query = SqlcQueryBuilder(sql)
      query.bind(input.p1)
      let rows = try await db.execute(query)
      var result: [Row] = []
      result.reserveCapacity(rows.count)
      for r in rows {
        result.append(
          Row(
            albumid: try r.decode(column: r.allColumns[0], as: Int.self),
            title: try r.decode(column: r.allColumns[1], as: String.self)
          ))
      }
      return result
    }
  }

  public enum GetArtistByID {
    public static let name: String = "GetArtistByID"
    public static let cmd: String = ":one"
    public static let sql: String = "SELECT ArtistId, Name\nFROM artists\nWHERE ArtistId = ?1"

    // Input type
    public struct Input: Sendable {
      public var p1: Int
      public init(p1: Int) {
        self.p1 = p1
      }
    }

    // Row type
    public struct Row: Sendable {
      public var artistid: Int
      public var name: String
    }

    // Convenience runner (matches SQLKit async API)
    public static func execute(on db: SQLiteConnection, input: Input) async throws -> Row? {
      var query = SqlcQueryBuilder(sql)
      query.bind(input.p1)
      if let r = try await db.execute(query).first {
        return Row(
          artistid: try r.decode(column: r.allColumns[0], as: Int.self),
          name: try r.decode(column: r.allColumns[1], as: String.self)
        )
      }
      return nil
    }
  }

  public enum CreateArtist {
    public static let name: String = "CreateArtist"
    public static let cmd: String = ":exec"
    public static let sql: String = "INSERT INTO artists (Name)\nVALUES (?1)"

    // Input type
    public struct Input: Sendable {
      public var p1: String
      public init(p1: String) {
        self.p1 = p1
      }
    }

    // Row type
    public struct Row: Sendable {
    }

    // Convenience runner (matches SQLKit async API)
    public static func execute(on db: SQLiteConnection, input: Input) async throws {
      var query = SqlcQueryBuilder(sql)
      query.bind(input.p1)
      _ = try await db.execute(query)
    }
  }

  public enum DeleteArtist {
    public static let name: String = "DeleteArtist"
    public static let cmd: String = ":exec"
    public static let sql: String = "DELETE FROM artists\nWHERE ArtistId = ?1"

    // Input type
    public struct Input: Sendable {
      public var p1: Int
      public init(p1: Int) {
        self.p1 = p1
      }
    }

    // Row type
    public struct Row: Sendable {
    }

    // Convenience runner (matches SQLKit async API)
    public static func execute(on db: SQLiteConnection, input: Input) async throws {
      var query = SqlcQueryBuilder(sql)
      query.bind(input.p1)
      _ = try await db.execute(query)
    }
  }
}
