// Code generated by sqlc using sqlc-gen-from-template; DO NOT EDIT.
// Template: query_template.swift.tmpl

import Foundation
import SQLiteNIO

public enum Query {

  public enum GetTracksByAlbum {
    public static var name: String { "GetTracksByAlbum" }
    public static var cmd: String { ":many" }
    public static var sql: String {
      "SELECT t.TrackId, t.Name, t.Milliseconds\nFROM tracks AS t\nWHERE t.AlbumId = ?1\nORDER BY t.TrackId"
    }

    public struct Input: Sendable {
      public var p1: Int
      public init(p1: Int) {
        self.p1 = p1
      }
    }

    public struct Row: Sendable {
      public var trackid: Int
      public var name: String
      public var milliseconds: Int
    }

    // Convenience runner (matches SQLKit async API)
    public static func execute(on db: SQLiteConnection, input: Input) async throws -> [Row] {
      var query = SqlcQueryBuilder(sql)
      query.bind(input.p1)
      let rows = try await db.execute(query)
      var result: [Row] = []
      result.reserveCapacity(rows.count)
      for row in rows {
        let columns = row.columns
        result.append(
          Row(
            trackid: try .decode(from: columns[0]), name: try .decode(from: columns[1]),
            milliseconds: try .decode(from: columns[2])
          ))
      }
      return result
    }
  }

  public enum SearchTracksByName {
    public static var name: String { "SearchTracksByName" }
    public static var cmd: String { ":many" }
    public static var sql: String {
      "SELECT TrackId, Name\nFROM tracks\nWHERE Name LIKE '%' || ?1 || '%'\nORDER BY Name\nLIMIT ?2"
    }

    public struct Input: Sendable {
      public var p1: String?
      public var p2: Int
      public init(p1: String?, p2: Int) {
        self.p1 = p1
        self.p2 = p2
      }
    }

    public struct Row: Sendable {
      public var trackid: Int
      public var name: String
    }

    // Convenience runner (matches SQLKit async API)
    public static func execute(on db: SQLiteConnection, input: Input) async throws -> [Row] {
      var query = SqlcQueryBuilder(sql)
      query.bind(input.p1)
      query.bind(input.p2)
      let rows = try await db.execute(query)
      var result: [Row] = []
      result.reserveCapacity(rows.count)
      for row in rows {
        let columns = row.columns
        result.append(
          Row(
            trackid: try .decode(from: columns[0]), name: try .decode(from: columns[1])
          ))
      }
      return result
    }
  }

  public enum GetAlbumsByArtist {
    public static var name: String { "GetAlbumsByArtist" }
    public static var cmd: String { ":many" }
    public static var sql: String {
      "SELECT a.AlbumId, a.Title\nFROM albums AS a\nWHERE a.ArtistId = ?1\nORDER BY a.AlbumId"
    }

    public struct Input: Sendable {
      public var p1: Int
      public init(p1: Int) {
        self.p1 = p1
      }
    }

    public struct Row: Sendable {
      public var albumid: Int
      public var title: String
    }

    // Convenience runner (matches SQLKit async API)
    public static func execute(on db: SQLiteConnection, input: Input) async throws -> [Row] {
      var query = SqlcQueryBuilder(sql)
      query.bind(input.p1)
      let rows = try await db.execute(query)
      var result: [Row] = []
      result.reserveCapacity(rows.count)
      for row in rows {
        let columns = row.columns
        result.append(
          Row(
            albumid: try .decode(from: columns[0]), title: try .decode(from: columns[1])
          ))
      }
      return result
    }
  }

  public enum GetArtistByID {
    public static var name: String { "GetArtistByID" }
    public static var cmd: String { ":one" }
    public static var sql: String { "SELECT ArtistId, Name\nFROM artists\nWHERE ArtistId = ?1" }

    public struct Input: Sendable {
      public var p1: Int
      public init(p1: Int) {
        self.p1 = p1
      }
    }

    public struct Row: Sendable {
      public var artistid: Int
      public var name: String
    }

    // Convenience runner (matches SQLKit async API)
    public static func execute(on db: SQLiteConnection, input: Input) async throws -> Row? {
      var query = SqlcQueryBuilder(sql)
      query.bind(input.p1)
      if let row = try await db.execute(query).first {
        let columns = row.columns
        return Row(
          artistid: try .decode(from: columns[0]), name: try .decode(from: columns[1])
        )
      }
      return nil
    }
  }

  public enum CreateArtist {
    public static var name: String { "CreateArtist" }
    public static var cmd: String { ":exec" }
    public static var sql: String { "INSERT INTO artists (Name)\nVALUES (?1)" }

    public struct Input: Sendable {
      public var p1: String
      public init(p1: String) {
        self.p1 = p1
      }
    }

    public struct Row: Sendable {
    }

    // Convenience runner (matches SQLKit async API)
    public static func execute(on db: SQLiteConnection, input: Input) async throws {
      var query = SqlcQueryBuilder(sql)
      query.bind(input.p1)
      _ = try await db.execute(query)
    }
  }

  public enum DeleteArtist {
    public static var name: String { "DeleteArtist" }
    public static var cmd: String { ":exec" }
    public static var sql: String { "DELETE FROM artists\nWHERE ArtistId = ?1" }

    public struct Input: Sendable {
      public var p1: Int
      public init(p1: Int) {
        self.p1 = p1
      }
    }

    public struct Row: Sendable {
    }

    // Convenience runner (matches SQLKit async API)
    public static func execute(on db: SQLiteConnection, input: Input) async throws {
      var query = SqlcQueryBuilder(sql)
      query.bind(input.p1)
      _ = try await db.execute(query)
    }
  }
}
